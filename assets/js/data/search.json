[ { "title": "Elixir for .NET Developers Part 1: Assignment", "url": "/posts/efdnd-part-1/", "categories": "Programming", "tags": "elixir, dotnet", "date": "2022-03-24 10:40:00 +0000", "snippet": "Throughout this series, I want to introduce the core concepts of Elixir andOTP using C# (with a couple of forays into F#) and .NET as comparison points.I hope to stress just how wonderful Elixir is and how as a frustrated C# Developerit has provided a much needed tonic (sorry) that has made me fall in love with programmingagain.Elixir is a functional, dynamic and extensible language that leverages the OTP(Open Telecom Platform) runtime originally utilised by the Erlang language.I’m fond of saying there is at least a surface level resemblance to Ruby, but ithas much more in common with a LISP past superficial syntactic similarities.Now, there is not much natural crossover between Elixir and C#, even somethingas seemingly simple as assignment functions quite differently between the two.Assignment and matchingGiven the following blocks of code, it is pretty easy to make the assumption thatthey are equivalent. We are assigning a variable, named test, to the value of 1.var test = 1;test = 1This is pretty much programming 101, the very foundation of most mainstreamlanguages regardless of the paradigm they use - whether object oriented,functional or imperative.Certain languages, such as Go, may change the operator slightly but we can allagree that this is immediately recognisable as assignment.test := 1test, regardless of language, is 1.This is of course the same as in Elixir. However, there is much more going onhere than simple assignment.Take the following:1 = 1&quot;test&quot; = &quot;test&quot;[1, 2, 3] = [1, 2, 3]This is valid Elixir code.But each of the left hand operands are discrete, static values! How can thispossibly work? You can’t assign the value 1 to 1 or an array to another array!What happens if we run the following Elixir code?2 = 1 ** (MatchError) no match of right hand side value: 12 is (obviously!) not 1.What is going on here?Assignment via pattern matchingIn Elixir, what we take as the assignment operator is in fact the matchoperator.Assignment happens via pattern matching and only if one or more identifiersare present on the left hand operand.I hesitate to use the term side effect as that is overloaded and typically usedto describe non-functional idioms, but it is maybe easier to think of it as such.This allows us to write things such as:[value, 2, 3] = [1, 2, 3]Or even:value1 = 1[value2, 2, 3] = [value1, 2, 3]" } ]
